<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
    <script src="lib/d3.js"></script>
    <style>
        .node {
            cursor: pointer;
            stroke: #3182bd;
            stroke-width: 1.5px;
        }

        .link {
            fill: none;
            stroke: #9ecae1;
            stroke-width: 1.5px;
        }
    </style>
</head>
<body>
<div id="graphDiv"></div>
<script>
    let COL_END_TIME = 'End Time', COL_NAME = 'Name', COL_DEVICE_ACTION = 'Device Action',
        COL_DEVICE_PRODUCT = 'Device Product', COL_DEVICE_VENDOR = 'Device Vendor',
        COL_SOURCE_ADDRESS = 'Source Address', COL_SOURCE_PORT = 'Source Port',
        COL_SOURCE_ZONE_NAME = 'Source Zone Name', COL_DESTINATION_ADDRESS = 'Destination Address',
        COL_DESTINATION_PORT = 'Destination Port', COL_DESTINATION_ZONE = 'Destination Zone Name';
    let margin = {left: 10, top: 10, right: 0, bottom: 0}, svgWidth = 800, svgHeight = 800,
        width = svgWidth - margin.left - margin.right, height = svgHeight - margin.top - margin.bottom;
    let svg = d3.select("#graphDiv").append("svg").attr("width", svgWidth).attr("height", svgHeight);
    svg.append("defs").append("marker")
        .attr("id", 'arrowhead')
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 15)
        .attr("refY", -1.5)
        .attr("markerWidth", 4)
        .attr("markerHeight", 4)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M0,-5L10,0L0,5");

    let mainG = svg.append('g').attr('transform', `translate(${margin.left}, ${margin.top})`);

    let link = mainG.selectAll('.link'),
        node = mainG.selectAll('.node');

    let simulation = d3.forceSimulation()
        .on('tick', tick);

    d3.csv('data/104.12.0.0.csv').then(data => {
        let graph = generateGraph(data);
        let nodes = graph.nodes;
        let links = graph.links;
        //Restart the simulation layout
        simulation.nodes(nodes)
            .force('link', d3.forceLink(links).id(d=>d.id))
            .force("charge", d3.forceManyBody())
            .force("center", d3.forceCenter(width / 2, height / 2)).alphaTarget(0.1).restart()
            .force();
        //Update the links
        link = link.data(links, d => d.index);

        //Exit any old links
        link.exit().remove();

        //Enter any new links
        let enterLink = link.enter().append('path').attr('class', "link")
            .attr("marker-end", "url(#arrowhead)");

        link = enterLink.merge(link);
        //Update the nodes
        node = node.data(nodes, d => d.id).style("fill", color);
        //Exit
        node.exit().remove();
        //enter any new nodes
        let enterNode = node.enter().append("circle")
            .attr("class", "node")
            .attr("cx", d => d.x)
            .attr("cy", d => d.y)
            .attr("r", d => {
                return 4.5
            })
            .style('fill', color)
            .call(d3.drag()
                .subject(dragsubject)
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended)
            );
        node = enterNode.merge(node);
    });
    function tick() {
        link.attr("d", linkArc);
        node.attr("cx", d => d.x).attr("cy", d => d.y);
    }

    function color(d){
        return 'steelblue';
    }

    function linkArc(d) {
        let dx = d.target.x - d.source.x,
            dy = d.target.y - d.source.y,
            dr = Math.sqrt(dx * dx + dy * dy);
            if(dr){
                return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
            }else{
                dr = 20;
                //M 100 100 a 50 50 0 1 0 0.00001 0
                return "M" + d.source.x + " " + d.source.y + " A " + dr + " " + dr + " 0 1 0 " + (d.target.x-0.01) + " " + (d.target.y-0.01);

            }


    }

    //<editor-fold desc="this section is for drag drop">
    function dragsubject() {
        return simulation.find(d3.event.x, d3.event.y);
    }
    function dragstarted() {
        if (!d3.event.active) simulation.alphaTarget(0.1).restart();
        d3.event.subject.fx = d3.event.subject.x;
        d3.event.subject.fy = d3.event.subject.y;
    }
    function dragged() {
        d3.event.subject.fx = d3.event.x;
        d3.event.subject.fy = d3.event.y;
    }
    function dragended() {
        if (!d3.event.active) simulation.alphaTarget(0);
        d3.event.subject.fx = null;
        d3.event.subject.fy = null;
    }
    //</editor-fold>

    //<editor-fold desc="This section is for data processing">
    function generateGraph(data) {
        let nodes = [];
        data.forEach(threatEvent => {
            nodes.push(threatEvent[COL_SOURCE_ADDRESS]);
            nodes.push(threatEvent[COL_DESTINATION_ADDRESS]);
        });
        nodes = Array.from(new Set(nodes));
        nodes = nodes.map(d=>{
            return {'id': d};
        });
        let nestedBySourceToTarget = d3.nest().key(d => d[COL_SOURCE_ADDRESS] + "," + d[COL_DESTINATION_ADDRESS]).entries(data);
        let links = nestedBySourceToTarget.map(d => {
            return {
                source: d.values[0][COL_SOURCE_ADDRESS],
                target: d.values[0][COL_DESTINATION_ADDRESS],
                threatEvents: d.values
            };
        });
        return {nodes: nodes, links: links};
    }
    //</editor-fold>

</script>
</body>
</html>